# 自定义view #
本文将从以下几个方面复习自定义view相关的知识：

**1. shape属性 、selector属性和自定义样式（style）**

**2. 自定义属性**

**3. 动画**

**4. 事件传递与分发**

**5. 自定义View**


## 1.shape属性 、selector属性和自定义样式（style） ##
**shape属性：**可以绘制出我们想要的形状，一些简单的效果例如，圆角的button，渐变背景色，填充效果都可以通过shape来实现，能缩小安装包体积，提高应用性能。
常用属性：android:shape=["rectangle"（矩形） | "oval"（椭圆） | "line"（线） | "ring"（环）]

**solid：**填充颜色

**corners：**圆角的弧度

**padding：**控件的内边距

**stroke:**设置边框

**gradient：**设置渐变



**selector属性：**一般用来给控件不同状态设置背景色。例如按钮点击效果的选择器，开关等。
总共有pressed、focused、selected、checkable、checked、enabled、window_focused和default八种状态，View对象的每一种状态可以设置不同的背景色。


**自定义样式（style）：**

开发过程中对于公共的样式抽取出来，方便以后复用。
使用的时候需要在res/values下创建一个xml文件。


## 2.自定义属性 ##
有的时候需要制作一些拥有固定效果的textView或者ImageView等，就需要通过自定义一些属性来实现。使用自定义属性步骤如下：

- 在res/values下创建一个xml文件例如attrs,在这个文件里给我们的自定义view声明一组属性。
- 在引用这个自定义view的布局文件里声明命名空间
- 自定义view的构造函数里获取属性值，按照需求对view进行设置。
### 2.1在res/values下创建一个xml文件例如attrs,在这个文件里给我们的自定义view声明一组属性  ###

    <?xml version="1.0" encoding="utf-8"?>
	<resources>
    <declare-styleable name="MyTextView">
        <attr name="text" format="string"/>
        <attr name="width" format="dimension"/>
        <attr name="height" format="dimension"/>
        <attr name="color" format="color"/>
        <attr name="size" format="dimension"/>
    </declare-styleable>
	</resources>

### 2.2 在引用这个自定义view的布局文件里声明命名空间###

    <?xml version="1.0" encoding="utf-8"?>
	<android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:mytextview="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context="com.dkp.viewdemo.MainActivity">

    <com.dkp.viewdemo.demo_myattrs.MyTextView
        android:id="@+id/tv"
        android:layout_height="wrap_content"
        android:layout_width="match_parent"
        mytextview:width="100dp"
        mytextview:height="40dp"
        mytextview:size="18sp"
        mytextview:color="#3dede4"
        mytextview:text="我是自定义的文本控件"
        app:layout_constraintBottom_toBottomOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintRight_toRightOf="parent"
        app:layout_constraintTop_toTopOf="parent" />


	</android.support.constraint.ConstraintLayout>

xmlns:mytextview="http://schemas.android.com/apk/res-auto"就是自己声明的命名空间mytextview的可以是任意名称。

### 2.3 自定义view的构造函数里获取属性值，按照需求对view进行设置。 ###
 

    package com.dkp.viewdemo.demo_myattrs;

	import android.content.Context;
	import android.content.res.TypedArray;
	import android.graphics.Color;
	import android.support.annotation.Nullable;
	import android.util.AttributeSet;

	import android.widget.TextView;import android.util.Log;

	import com.dkp.viewdemo.R;

	/**
 	 * Created by Administrator on 2019/5/8.
 	 */

	public class MyTextView extends android.support.v7.widget.AppCompatTextView {


    public MyTextView(Context context) {
        super(context);
        init(context,null,0);
    }

    public MyTextView(Context context, @Nullable AttributeSet attrs) {
        super(context, attrs);
        init(context,attrs,0);
    }

    public MyTextView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init(context,attrs,defStyleAttr);
    }

    /**
     * 初始化
     * @param context
     * @param attrs
     * @param defStyleAttr
     */
    private void init(Context context, AttributeSet attrs, int defStyleAttr) {
        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.MyTextView);
        String text = ta.getString(R.styleable.MyTextView_text);
        int mTextColor = ta.getColor(R.styleable.MyTextView_color, Color.BLACK);
        int mTextSize = ta.getDimensionPixelSize(R.styleable.MyTextView_size, 18);
        int mTextHeight = ta.getDimensionPixelSize(R.styleable.MyTextView_height, 40);
        int mTextWidth = ta.getDimensionPixelSize(R.styleable.MyTextView_width, 100);
        setText(text);
        setTextColor(mTextColor);
        setTextSize(mTextSize);
        setHeight(mTextHeight);
        setWidth(mTextWidth);
        ta.recycle();  //注意回收
        Log.v("MyTextView","text属性值:"+text);
        Log.v("MyTextView", "mTextColor属性值:"+mTextColor);
        Log.v("MyTextView", "mTextSize属性值:"+mTextSize);
        Log.v("MyTextView", "mTextHeight属性值:"+mTextHeight);
        Log.v("MyTextView", "mTextWidth属性值:"+mTextWidth);
    }

	}



## 3.动画 ##
动画分类：我们可以把动画分为两大类:

1. 视图动画
2. 属性动画。

### 3.1视图动画 ###
视图动画又分为：补间动画和帧动画。

**补间动画**可以分为：平移动画（Translate）、缩放动画（scale）、旋转动画（rotate）、透明度动画（alpha）

特点：优:使用简单方便;缺点：只能控制整体的效果，无法控制属性。

应用场景：1.视图中标准、基础的动画效果2.Activity、Fragment的切换效果3.视图组中子元素的进出效果

**帧动画**帧动画按顺序播放一组预先定义好的一组图片，每一张图片对应一帧。

特点:优点使用简单方便，缺点：容易引起OOM，图片注意压缩，不要太大。

应用场景：较复杂的个性动画效果。
### 3.2属性动画 ###


由于视觉动画在一些场景上满足不了我们的需求，例如要实现视图颜色动态变化，那么需要操作视图的颜色属性，这个是补间动画或者帧动画都做不到的；再比如将视图一个视图从右上角采用补间动画平移到右下角，点击右下角的视图发现没有效果，因为这个视图还在右上角，补间动画只是将这个视图平移到了右下角，改变了视觉效果而已。

作用对象：任意Java对象，不再局限于视图View对象，在一定的时间间隔内，通过不断的对值进行改变并且不断的将该值赋给对象的属性，从而实现该对象在该属性上的动画效果，可以是任意对象的任意属性。

特点：作用对象扩大，不只是四种基本变化，还有其他动画效果。

应用场景：与属性相关、更加复杂的动画效果。


#### 3.2.1 ValueAnimator类 ####
例如：将一个button的宽拉长到500的动画

        private void initButtonWidChangeAnimator() {
        //步骤1：设置按钮的初始值&结束值
        ValueAnimator buttonAnimator = ValueAnimator.ofInt(myButton.getLayoutParams().width,500);
        //步骤2：设置动画的各种属性
        buttonAnimator.setDuration(500);
        buttonAnimator.setRepeatMode(ValueAnimator.RESTART);
        buttonAnimator.setRepeatCount(0);
        buttonAnimator.setStartDelay(1000);
        //步骤3：通过动画的更新监听器，将变化的属性值手动赋值给对象
        buttonAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator valueAnimator) {
                int currentValue = (int) valueAnimator.getAnimatedValue();
                myButton.getLayoutParams().width = currentValue;
         //步骤4：刷新view,实现动画效果
                myButton.requestLayout();
            }
        });

        buttonAnimator.start();
    }

    
#### 3.2.2 ObjectAnimator 类 ####

**原理**：直接对对象的属性值进行改变操作，从而实现动画效果

- 如直接改变 View的 alpha 属性 从而实现透明度的动画效果
- 继承自ValueAnimator类，即底层的动画实现机制是基于ValueAnimator类

控制透明度动画

        private void initObjectAnimator() {

	        ObjectAnimator buttonObjectAnimator = ObjectAnimator.ofFloat(myButton,"alpha",1f,0f,1f);
	        buttonObjectAnimator.setRepeatCount(ObjectAnimator.INFINITE);
	        buttonObjectAnimator.setRepeatMode(ObjectAnimator.RESTART);
	        buttonObjectAnimator.setDuration(3000);
	        buttonObjectAnimator.setStartDelay(2000);
	        buttonObjectAnimator.start();
    }
旋转动画

     /**
     * ObjectAnimator
     * 旋转变化
     */
    private void initObjectAnimator_Rotation() {
        //步骤1：设置动画的初始值&结束值
        ObjectAnimator buttonObjectAnimator = ObjectAnimator.ofFloat(myButton,"rotation",0f,360f);
        //步骤2：设置动画的各种属性
        buttonObjectAnimator.setRepeatCount(ObjectAnimator.INFINITE);
        buttonObjectAnimator.setRepeatMode(ObjectAnimator.RESTART);
        buttonObjectAnimator.setDuration(3000);
        buttonObjectAnimator.setStartDelay(2000);
        //步骤3：开启动画
        buttonObjectAnimator.start();
    }

平移动画

     /**
     * ObjectAnimator
     * 平移变化
     */
    private void initObjectAnimator_translation() {
        float currentX = myButton.getTranslationX();
        float currentY = myButton.getTranslationY();
        float currentZ = myButton.getTranslationZ();


        //步骤1：设置动画的初始值&结束值,currentX到500f,然后再回到currentX
        ObjectAnimator buttonObjectAnimator = ObjectAnimator.ofFloat(myButton,"translationX",currentX,500f,currentX);
        //步骤2：设置动画的各种属性
        buttonObjectAnimator.setRepeatCount(ObjectAnimator.INFINITE);
        buttonObjectAnimator.setRepeatMode(ObjectAnimator.RESTART);
        buttonObjectAnimator.setDuration(3000);
        buttonObjectAnimator.setStartDelay(2000);
        //步骤3：开启动画
        buttonObjectAnimator.start();
    }

缩放动画：

     /**
     * ObjectAnimator
     * 缩放变化
     */
    private void initObjectAnimator_scaleX() {

        //步骤1：设置动画的初始值&结束值,1f到3f,然后再回到1f
        ObjectAnimator buttonObjectAnimator = ObjectAnimator.ofFloat(myButton,"scaleX",1f,3f,0.3f);
        //步骤2：设置动画的各种属性
        buttonObjectAnimator.setRepeatCount(ObjectAnimator.INFINITE);
        buttonObjectAnimator.setRepeatMode(ObjectAnimator.RESTART);
        buttonObjectAnimator.setDuration(3000);
        buttonObjectAnimator.setStartDelay(2000);
        //步骤3：开启动画
        buttonObjectAnimator.start();
    }


#### 3.2.3 AnimatorSet 动画集合 ####
多个动画同时播放：

     /**
     * 动画集合，实现多个动画同时播放
     */
    private void initAnimatorSet() {
        AnimatorSet set = new AnimatorSet();
        //playSequentially顺序一个一个的播放，playTogether多个动画同时一起播放
        set.playTogether(ObjectAnimator.ofFloat(myButton,"rotationX",0,360),
                ObjectAnimator.ofFloat(myButton,"rotationY",0,180),
                ObjectAnimator.ofFloat(myButton,"rotation",0,-90),
                ObjectAnimator.ofFloat(myButton,"translationX",0,90),
                ObjectAnimator.ofFloat(myButton,"translationY",0,90),
                ObjectAnimator.ofFloat(myButton,"scaleX",1,3f),
                ObjectAnimator.ofFloat(myButton,"scaleY",1,3f),
                ObjectAnimator.ofFloat(myButton,"alpha",1,0.25f,1)
                );
        set.setDuration(3000).setStartDelay(1000);
        set.start();

    }

## 4.事件传递与分发 ##









参考链接：[属性动画使用及原理](https://blog.csdn.net/carson_ho/article/details/72909894)